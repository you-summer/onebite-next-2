데이터 패칭

기존 리액트 방식은 백엔드 서버로부터 불러온 데이터가 화면에 나타나기까지 걸리는 시간이
매우 오래걸림 (초기 접속 요청부터 데이터 로딩까지 오랜 시간이 걸림)
백엔드 서버에서 보내는 데이터 요청이 컴포넌트가 마운트 된 이후에나 발생하게 되기 때문
애초에 데이터 요청 자체가 늦게 시작해버리기 때문에 데이터를 불러오는 속도도 늦어지게 됨

리액트 앱은 클라이언트 사이드 렌더링 이라고 해서 브라우저가 렌더링을 직접 처리하는 방식으로 동작함
그래서 이 페이지가 실제로 화면에 그려지기까지 브라우저가 HTML도 렌더링을 해야하고 후속으로 전달받은 JS 코드까지도 직접 다 실행을 시켰어야만 했기 때문에 결론적으로 FCP가 꽤 늦어짐
그래서 가뜩이나 초기접속이 느린 리액트 앱에서 컴포넌트가 마운트된 이후가 되어서야 백엔드 서버에게 데이터를 요청하도록 코드를 작성해주게 되면 느린 FCP를 거치고나서야 백엔드 서버에게 데이터를 요청하게 되기 때문에 데이터의 로딩이 완료되기까지 추가적인 시간이 더 소요되게 됨
그렇기 때문에 사용자 입장에서는 FCP이후에 데이터를 기다려야하는시간이 추가되는거임!!

Next에서는 리액트의 느린 FCP문제를 해결하기 위해서 사전렌더링이란 방식으로 동작을 함

사전렌더링?
- 브라우저가 초기접속요청을 보냈을때 Next서버 측에서 해당 페이지에 필요한 자바스크립트 코드들을 모두 실행을 시켜서 우리가 만든 리액트 컴포넌트들을 다 HTML로 렌더링을 마친다음에
그렇게 렌더링이 완성된 HTML 파일을 바로 브라우저에게 응답해주는 방식이었음

브라우저는 서버로부터 완성된 HTML파일을 바로 받아서 그대로 화면에 렌더링하면 바로 완성된 화면을 사용자에게 보여줄수있기 때문에 리액트 앱의 느린 FCP문제점을 해결할수있는게 사전 렌더링임!

이때 추가로 서버 측에서 자바스크립트 코드를 실행해서 사전 렌더링을 직접 진행하는 과정에서 사실은 백엔드 서버로부터 현재 페이지에 필요한 데이터를 미리 불러오도록 설정까지 할수가있음

그렇기 때문에 리액트 앱에서의 데이터 패칭보다 훨씬 더 빠른 타이밍에 백엔드 서버로부터 데이터를 요청하고 불러올 수 있음

그럼으로 인해서 이때 서버가 브라우저에게 전달하는 이 렌더링이 완료된 HTML파일에는 이미 백엔드 서버로부터 불러온 데이터들이 다 포함이 되어 있을테니 결국 사용자에게 데이터 패칭이 완료된 페이지를 추가적인 로딩없이 한방에 바로 보여줄 수 있다는 장점을 가지고있음 

React App의 데이터 패칭
- 컴포넌트 마운트 이후에 발생함
- 데이터 요청 시점이 느려지게 되는 단점 발생

Next App의 데이터 패칭
- 사전 렌더링중 발생함 (당연히 컴포넌트 마운트 이후에도 발생 가능)
- 데이터 요청 시점이 매우 빨라지는 장점 있음

넥스트는 3가지의 사전 렌더링 방식을 제공하고있음!
1. 서버 사이드 렌더링 (SSR)
- 가장 기본적인 사전 렌더링 방식
- 요청이 들어올 때 마다 사전 렌더링을 진행 함

2. 정적 사이트 생성 (SSG)
- 방금 살펴본 사전 렌더링 방식
- 빌드 타임에 미리 페이지를 사전 렌더링 해 둠

3. 증분 정적 재생성 (ISR)
- 향후에 다룰 사전 렌더링 방식




!!!!!!! SSR(서버 사이드 렌더링) !!!!!!!
브라우저에 접속 요청이 들어올 때마다 매번 새롭게 페이지를 사전 렌더링하는 방식

export const getServerSideProps = () => {};
// 이 한줄로 ssr이 설정됨

getServerSideProps 라는 약속된 이름의 함수를 만들어서 export로 내보내줬기 때문
next에서는 페이지 역할을 하는 파일 안에 getServerSideProps 같은 넥스트에서 약속된 이름의 함수를 만들어서 내보내주게 되면 해당 페이지는 이제부터 SSR로 동작하도록 설정이 됨

getServerSideProps
브라우저에서 localhost:3000의 인덱스경로로 이 인덱스 페이지를 요청해서 넥스트 서버가 사전 렌더링을 하게 될 때 페이지 컴포넌트보다 먼저 실행이 되어서 인덱스 페이지에 필요한 데이터를 또 다른 백엔드 서버로부터 불러온다던가 하는 그러한 기능을 하게 되는 함수임

쉽게 말하자면 1번으로 인덱스 페이지 경로로 요청이 들어오게 되었을때 2번 getServerSideProps함수가 동작을 해서 백엔드 서버로부터 데이터를 불러온다던가 서드파티로부터 데이터를 불러온다다던가 이런 일들을 한 다음에 마지막 3번으로 페이지 컴포넌트가 실행이 됨

export const getServerSideProps = () => {
  // 컴포넌트보다 먼저 실행되어서, 컴포넌트에 필요한 데이터 불러오는 함수
};



export const getServerSideProps = () => {
  const data = "hello";
  // 백엔드에서 hello라는 값으로 data를 받아온다고 쳤을때
  // 밑에 리턴의 props값으로 data를 보내줄 수 있음

  return {
    props: {
      data,
    },
  };
};

getServerSideProps라는 함수의 리턴값은 반드시 props라는 객체 프로퍼티를 포함하는 단 하나의 객체여야만 함
getServerSideProps는 객체를 반환해야 하는데! 그 객체안에는 객체타입의 props가 들어가 있어야 한다는것
왜 그러냐면 그래야만 Next.js 앱이 
  return {
    props: {
      data,
    },
  };
이 객체를 읽어와서 이 객체 안에 있는 props라는 프로퍼티 값을 페이지 역할을 하는 컴포넌트에게 전달할수있기 때문!
그래서 이거는 그냥 프레임워크의 일종의 문법이라고 생각하면 됨
그냥 강제적으로 이렇게 사용해야한다~ 라고 보면됨

getServerSideProps라는 함수 안에서 data라는 이름으로 hello라는 값을 페이지 컴포넌트에게 전달하도록 설정해 주면 페이지 컴포넌트 에서는 기존의 리액트 앱에서 props를 받아오듯이 똑같이 받아오면됨

getServerSideProps 이건 페이지 컴포넌트보다 먼저 실행되어서 페이지 컴포넌트에 필요한 데이터를 백엔드 서버라던지 어떤 곳에서 구해다가 페이지 컴포넌트에게 이렇게 props로 넘겨주는 역할을 하는 함수임!

그렇기때문에 한가지 주의해주셔야 할 점이 이 함수는 사전 렌더링을 하는 과정에서 딱 한번만 실행될거기 때문에 서버 측에서만 실행이 되는 함수라는 점입니다


export const getServerSideProps = () => {
  const data = "hello";

  console.log("서버사이드프롭스예요");

  return {
    props: {
      data,
    },
  };
};
이렇게 해당 함수안에 console.log("서버사이드프롭스예요") 이건 f12 개발자모드 콘솔에서 보이지 않음

넥스트 서버의 로그가 나오고 있는 터미널에서 출력됨
getServerSideProps 함수 내부에서 브라우저 환경에서만 이용할 수 있는 window객체의 window.location에 접근하려고하면 오류남

왜냐면 자바스크립트의 window는 브라우저를 의미함 그래서 서버환경에서만 실행되는 getServerSideProps 함수 안에서는 브라우저를 읽을 수가 없음

alert이런것도 사용할 수 없음

페이지 역할을하는 Home컴포넌트 또한 서버에서 한번 먼저 실행이 된 다음에 브라우저에서 한번 더 실행이 됨
왜냐면 첫번째로는 브라우저로부터 접속요청을 받았을 때 사전렌더링을 위해서 서버측에서 한번 컴포넌트가 실행이 될거고 두번째로는 브라우저에서 자바스크립트 번들 형태로 전달이 되어서 브라우저 측에서 실행이 될때 하이드레이션 과정이 진행 될 때 한번 더 실행 되어서 결국 서버에서 한번 브라우저에서 한번으로 총 2번 실행됨

그렇기 때문에 home 컴포넌트 안에서 console.log(data)를 하게 되면 이 메세지는 총 2번이 출력됨
vs코드 터미널에서 한번 , 브라우저쪽에서도 한번 출력됨 

요점은 이 컴포넌트들 또한 서버에서 한 번은 실행이 될 테니까 당연히 컴포넌트 안에서도 조건도 없이 그냥 window.location 하게 되면 오류가 발생할수있게됨
왜냐면 window.location이 서버에서 실행될 때에는 윈도우가 undefined가 되어버려서 undefined.location을 호출하는게 되어버리기 때문!

만약 브라우저에서만 실행되는 코드를 작성하고 싶다면
useEffect를 이용하면 됨 컴포넌트의 마운트 시점 이후에~~
ㄴ 이 조건 자체가 컴포넌트가 마운트 된 이후 화면에 나타난 이후에 실행되는 함수를 만드는 곳이기 때문에!

getServerSideProps로 부터 props 데이터를 전달받는 페이지 컴포넌트의 props 타입은 어떻게 정의해야 하는지?

Next에서는 다양한 내장 타입들이 제공됨
그래서 대부분 타입 정의들은 사실 Next.js에서 제공하는 것들만 이용해도 거의 다 가능함
InferGetServerSidePropsType
getServerSideProps 함수의 반환값 타입을 자동으로 추론해주는 기능을 하는 타입

InferGetServerSidePropsType<typeof getServerSideProps>
자동으로 
  return {
    props: {
      data,
    },
  };
이 값의 타입이 추론이 되어서 매개변수 타입으로 정의가 됨




API 호출을 할건데 기존 index.tsx에 하면 너무 파일이 길어질거같음 !
그래서 
src/lib/fetch-book.ts (모든 책을 불러오는 함수)
