보통 우리는 HTML로 코드를 작성할 때는 다른 페이지로 이동하는 링크를 만들고 싶다면

a태그를 사용했었음 

근데 이 태그는 클라이언트 사이드 렌더링 방식으로 페이지를 이동시키는게 아닌

일반적인 방식으로 즉 서버에게 새로운 페이지를 매번 다시 요청하는 방식으로 페이지를 이동시켜주기 때문에 비교적 느린방식으로 페이지를 이동시켜주게 됨



그래서 넥스트 앱에서는 링크를 만들때 a태그 보다는 자체적으로 제공하는 내장 컴포넌트인 링크 컴포넌트를 이용하는 게 훨씬 좋음



import Link from "next/link";



링크 컴포넌트는 기본적으로 a태그와 사용법이 동일함



export default function App({ Component, pageProps }: AppProps) {

&nbsp; return (

&nbsp;   <>

&nbsp;     <header>

&nbsp;       <Link href={"/"}>index</Link>

&nbsp;       \&nbsp;

&nbsp;       <Link href={"/search"}>search</Link>

&nbsp;       \&nbsp;

&nbsp;       <Link href={"/book/1"}>book</Link>

&nbsp;     </header>

&nbsp;     <Component {...pageProps} />

&nbsp;   </>

&nbsp; );

}



href 속성으로 링크를 이동시키고자 하는 페이지의 경로를 명시해준 다음에

링크의 텍스트까지 작성해주면 브라우저에 클라이언트 사이드 렌더링 방식으로 페이지를 이동시키는 

링크가 잘 렌더링 됨



우리가 페이지를 이동시킬때마다 클라이언트 사이드 렌더링 방식으로 페이지를 이동시키기 때문에 아주 빠르고 쾌적하게 페이지 이동이 제공되고 있음



링크로 페이지 이동시키는게 아닌 어떤 함수가 실행된다거나 어떤 이벤트가 발생했을때에도

페이지를 이동시킬 수 있는 **프로그로매틱한 페이지 이동( Programmatic Navigation)**에 대해서도 살펴보도록 할거임 



**프로그래매틱하게 페이지를 이동** 시킨다는말은 사용자가 링크를 클릭했을때 페이지를 이동시키는 방식이 아니라 특정 버튼이 클릭되었거나 특정 조건이 만족했을 경우에 어떠한 함수 내부에서 페이지를 이동시키는 그런방법!



버튼 하나 추가한 다음 해당 버튼을 클릭했을때 이벤트핸들러 함수 안에서 페이지를 이동시키는 기능을 구현!





import "@/styles/globals.css";

import type { AppProps } from "next/app";

import Link from "next/link";

import { useRouter } from "next/router";



export default function App({ Component, pageProps }: AppProps) {

&nbsp; const router = useRouter();

&nbsp; const onClickButton = () => {

&nbsp;   router.push(`/test`);

&nbsp; };



&nbsp; return (

&nbsp;   <>

&nbsp;     <header>

&nbsp;       <Link href={"/"}>index</Link>

&nbsp;       \&nbsp;

&nbsp;       <Link href={"/search"}>search</Link>

&nbsp;       \&nbsp;

&nbsp;       <Link href={"/book/1"}>book</Link>

&nbsp;       <div>

&nbsp;         <button onClick={onClickButton}>/test</button>

&nbsp;       </div>

&nbsp;     </header>

&nbsp;     <Component {...pageProps} />

&nbsp;   </>

&nbsp; );

}



onClickButton을 만들어서 버튼을 클릭했을때 실행할 함수를 만들어주고

useRouter 호출해서 router.push하고 ()괄호안에 이동하고자 하는 주소를 입력해주면 됨!

router 객체의 push 메서드를 실행함

그러면 라우터 객체의 푸시메서드는 인수로 전달받은 경로로 페이지를 클라이언트 사이드 렌더링 방식으로 이동시켜줌



그래서 이런 방식으로 특정 조건을 만족했다거나 useEffect를 통해서 어떤 상황을 가정한다거나 했을때 이런 식으로 함수 내부에서도 페이지를 클라이언트 사이드 렌더링 방식으로 이동시킬 수 있다! 라는걸 기억ㅎㅐ두자



참고

router에는 push메서드 말고도 replace(뒤로가기를 방지하면서 페이지 이동), back(페이지를 뒤로 이동)

참고해서 사용해보기



## 프리페칭

Pre-fecting (pre 사전에, 미리 | Fetching 불러온다)

사전에 미리 불러온다 라는 뜻

페이지를 사전에 불러옴!



Next.js의 프리페칭은 현재 사용자가 현재 보고있는 페이지에서 링크들을 통해 이동할 수 있는 현재 연결되어있는 모든 페이지들을 사전에 미리 다 불러와 놓는 그런 기능들을 말함

현재 사용자가 보고 있는 페이지 내에서 이동할 가능성이 있는 모든 페이지들을 사전에 미리 다 불러놓는 그런 기능임



Next.js가 이런 기능을 기본적으로 제공하는 이유는 사용자들이 다른 페이지로 이동하기 위해서 웹페이지 내부의 링크를 클릭하기 전에 현재 페이지에서 이동이 가능한 모든 페이지들에 필요한 데이터를 미리 다 불러와 놓음으로써 페이지 이동을 매우 빠른 속도로 지체 없이 처리해주기 위해서!





넥스트에서는 초기 접속 요청이 발생했을때 서버가 브라우저에게 이 과정에서 사전 렌더링된 HTML페이지를 응답한 이후에 후속으로 모든 자바스크립트 코드를 번들 파일 형태로 전달해주기 때문에 결국 초기 접속 요청이 종료된 이후에 발생하게 되는 페이지 이동들은 서버에게 별도의 추가적인 요청없이 브라우저 측에서 직접 자바스크립트 코드를 실행시켜서, 즉 리액트 앱을 직접 실행시켜서 필요한 컴포넌트들을 교체하는 방식으로 즉, 클라이언트 사이드 렌더링 방식으로 알아서 처리를 하게 된다. 



그렇기 때문에 우리가 이런식으로 페이지를 이동시키게 되더라도 사실상 브라우저가 서버에게 추가적인 리소스를 요청할 필요가 없는걸로 이미 알고있는데 왜 이런 프리패칭같은 기능이 필요한걸까 뭔가 앞뒤가 안맞는거같음!



그러니까 이미 초기 접속 요청이 완료가 되어서 페이지 렌더링이 됐는데 왜 그 상태에서 다른 페이지로 이동하기 위해 추가적인 데이터를 왜 또 불러와야 되냐는 거임



사실 넥스트는 우리가 넥스트 앱에 작성해 두었던 모든 자바스크립트 코드들을 우리가 작성한 모든 리액트 컴포넌트들을 자동으로 페이지별로 (/index, /search, /book) 스플리팅해서 페이지별로 분리해서 저장을 미리 해둠

그래서 사전 렌더링의 과정에서 이러ㄴ식으로 JS번들, 자바스크립트 번들 파일을 전달할 때 모든 페이지에서 필요한 자바스크립트 코드가 다 전달되는게 아니라 현재 페이지에 해당하는 자바스크립트 코드들만 딱 전달이 됨

(현재 페이지에 필요한 JS Bundle만 전달됨, ex) "/search"접속요청 -> Search JS Bundle)



그래서 예를들어 사용자가 /search 페이지로 접속요청을 보냈다면 다시 전달되는 JS Bundle 파일에는 search 페이지에 해당하는 코드들만 전달이 되는거임



이렇게 동작하는 이유는 이 과정에서 전달되는 JS코드의 양을 줄이기 위해서!



왜냐면 초기 접속 요청이 있을 때마다 모든 페이지에 해당하는 JS코드들을 매번 다 번들링해서 전달하게 되면 한 번에 전달되는 파일의 용량이 매우 커지게 됨







결국 JS Bundle 하는 과정에서 용량이 커지게 되기 때문에 다운로드 받는 속도도 브라우저에서 느려지게 됨

그러면 당연히 자바스크립트 코드들을 실행해서 브라우저에서 렌더링 되어있는 HTML과 연결하는 이 하이드레이션 과정도 오래 걸리게 됨

그러면 결론적으로는 유저가 이러한 앱에 상호작용할 수 있게 되는 시간인 TTI가 최종적으로 늦어지게 되는 문제가 발생함

(만약 모든 페이지의 번들 파일을 전달할 경우 용량이 너무 커지게 되며 하이드레이션이 늦어진다)



그래서 대신에 우리 넥스트는 좀 더 경제적으로 이 문제를 해결하기 위해서 사용자가 현재 접속을 요청한 페이지에 해당하는 JS코드드ㄹ만 따로따로 보내주게도ㅣㅁ

(현재 페이지에 필요한 JS Bundle만 전달된다, 용량 경량화로 인해 Hydration 시간이 단축된다)



이렇게만 끝내버리면 결국 초기접속 이후에 발생하게 되는 페이지 이동들은 클라이언트 사이드 렌더링 방식ㅇㅡ로 추가적인 요청없이 바로바로 처리될수 있는게 아님

왜냐면 페이지를 이동하게 되면 초기 접속한 페이지에서 다른 페이지로 이동하게 될텐데 앞서 말한것처럼 넥스트는 초기 접속시에 현재 접속 요청을 한 페이지에 해당하는 js코드만 보내준다고 했음 

그렇기 때문에 다시 페이지를 이동하려고 하면 이동하려는 페이지에 필요한 js코드를 추가로 또 불러와야 되는 과정이 필요하게됨



이런방식으로 동작하면 하이드레이션은 빨라질 수 있겠지만 오히려 페이지 이동은 조금 느려지고 비효율적으로 바뀌게 됨



그래서 이런 문제를 방지하기 위해서 Pre-Fetching 기능이 추가로 작용됨



프리페칭은

현재 사용자가 보고 있는 웹 페이지에서 링크가 존재한다거나 버튼이 존재해서 이동할 수 있는 가능성이 있는 모든 페이지들에 즉, 연결된 모든 페이지들에 자바스크립트 코드를 미리 불러와 놓는 과정



그렇기 때문에 초기 접속이 완료된 이후 곧바로 페이지 이동이 이루어지기 전에 프리패칭이 발생해서 현재 페이지와 연결된,, 현재 페이지에서 이동할 수 있는 모든 페이지들의 자바스크립트 코드를 사전에 다 불러와 놓기 때문에 페이지를 이동할 때에는 결국 추가적인 데이터를 서버에게 요청할 필요가 없어져서 기존처럼 클라이언트 사이드 렌더링 방식의 장점대로 굉장히 빠른 속도로 페이지를 이동시킬 수 있게 되는 거임 



프리패칭은 결국 원래라면 페이지를 이동시킬때마다 자바스크립트 코드를 서버로부터 불러와야 했던 단점을 그 이전에 미리 페이지 이동 요청이 발생하기 전에 미리 불러와 놓음으로써 페이지 이동을 훨씬 빠르게 동작할 수 있도록 만들어주는 좋은 기능이다~~



현재 접속 요청이 발생한 페이지에 해당하는 자바스크립트 번들 파일만 전달이 되고 그 이후에 페이지 이동을 빠르게 제공하기 위해서 이런식으로 페이지에 접속한 이후에는 프리패칭이라는 기능을 통햇ㅓ 현재 페이지에서 이동할 수 있는 모든 페이지들에 대한 자바스크립트 코드를 사전에 미리 다 불러와 놓게 된다~



초기 접속 요청시에 하이드레이션을 더 빠르게 처리할 수 있도록 만들어 주면서도 동시에 프리패칭을 통해서 초기 접속 요청 이후에 페이지 이동까지 빠르게 처리할수있는 두 마리 토끼를 다 잡ㄴㅡㄴ 방식으로 동작한ㄷㅏ!



개발모드 (npm run dev)로 가동해 놓을때는 프리패칭이 동작하지 않음



그래서 npm run build로 빌드해줘야함



프리패칭 확인하기 위해서 npm run start로 넥스트 앱을 프로덕션 모드로 실행함



이렇게하고 f12의 네트워크 탭을 보면 search나 book페이지에 필요한 js코드들을 미리 불러와놓는걸 볼 수 있음!



그래서 search와 book페이지는 프리패칭이 완료된 상태기 때문에 search나 book페이지로 이동해도 네트워크탭에서 추가적인 요청이 발생하지 않음 



근데 예외적으로 /test로 이동하는 버튼을 클릭해서 페이지를 이동하게 되면 이때는 자바스크립트 번들을 추가로 불러오는걸 볼 수 있음



그러니까 이 테스트 페이지에는 예외적으로 프리패칭이 이루어져있지 않은거임!!

이거는 왜 그런거냐면 



\_app.tsx를 보면 프리패칭이 이루어졌던 search나 book페이지를 보면 링크컴포넌트로 구현이 되어있음

test페이지같은 경우에는 프로그래머틱하게 페이지를 이동하도록 설정이 되어있음

결론적으로 링크컴포넌트로 명시된 경로가 아니라면 프리패칭이 이루어지지 않음



이때 test페이지도 프리패칭 시켜주고 싶으면 

앱 컴포넌트가 화면에 마운트 되었을때, 화면에 처음 그려지게 되었을때 

&nbsp; const router = useRouter();

라우터 객체의 특정 메소드를 통해서 직접 프로그래머틱하게 테스트 페이지를 프리패칭하도록 작성해주면 됨 



마운트 되었을 때 실행할 동작을 정의 (useEffect)

마운트 되었을때만 딱 한번 실행시킬거니까 의존성 배열 deps는 빈배열로!

&nbsp; useEffect(() => {

&nbsp;   router.prefetch("/test");

&nbsp; }, \[]);

router객체의 prefecth그리고 ()안에는 어느 페이지를 프리패칭할건지 적어주면됨



이 앱 컴포넌트가 화면에 마운트 되고 나서 곧바로 router.prefetch 함수가 실행이 되면서 테스트 페이지에 대한 프리패칭이 실행이 될거임 



이렇게 하면 test에 필요한 코드도 프리패칭 되고 있는걸 볼 수 있음!



이런식으로 프로그래머틱하게 이동하는 페이지에 대해서도 프리패칭을 적용하고 싶다면 router객체의 prefetch메서드를 통해서 특정페이지를 명시적으로 설정할 수 있다!



강제로 프리패칭되는 link컴포넌트의 프리패칭을 해제하는 방법

&nbsp;       <Link href={"/search"} prefetch={false}>

&nbsp;         search

&nbsp;       </Link>

이런식으로 prefetch를 false로 바꿔줌





## **API Routes**

Next앱에서 API를 구축할 수 있도록 도와주는 API Routes라는 기능에 대해서 배울거임

Next.js앱에서 API를 구축할수있도록 만들어 주는 기능임

그래서 이 기능을 이용하면 백엔드 API 서버가 하는 일과 동일하게 간단한 API를 구축해서 클라이언트 즉, 브라우저로부터 요청을 받아 데이터베이스에서 데이터를 꺼내온다던ㄱㅏ 아니면 또 다른 서드파티에 데이터를 불러와서 전달을 해준다던지 이런 동작들으ㄹ 직접 만들어볼수있음



/src/pages/api 폴더가 기본으로 이미 생성이 되어있음

안에는 hello.ts파일이 있고 해당 파일을 열어서 내용을 확인해보면 

API의 응답코드가 기초적으로 작성이 되어있음



해당파일은 웹페이지가 아닌 API Routes로써 API응답을 정의하는 파일로써 자동으로 설정됨

API경로는 /api/hello.ts 이 폴더의 구조에 맞춰서 api의 hello라는 경로를 갖게됨



브라우저를 통해서 이러한 경로로 API를 요청하게 되면 이 hello.ts 파일 안에 써져있는 

export default function handler(

&nbsp; req: NextApiRequest,

&nbsp; res: NextApiResponse<Data>,

) {

&nbsp; res.status(200).json({ name: "John Doe" });

}
핸들러라는 함수가 실행되어 api가 작동하게됨 

이때 핸들러 함수의 내부를 자세히 보면

두개의 매개변수로 req와 res 에 대한 정보를 받고있음 



함수 내부에서는 response객체의 json이라는 메서드를 통해서 name은 john Doe라는 json객체를 응답하고 있음



그리고 이때 추가로 status라는 메서드를 통해서 상태 코드를 200번으로 설정하고 있음

(상태코드 200 : 요청이 성공적으로 처리되었음을 의미)



http://localhost:3000/api/hello

그래서 이 주소로 들어가게 되면 

{"name":"John Doe"}

이런식으로 설정한 객체가 API의 응답으로 잘 돌아오는걸 확인할 수 있음!



이렇게 Next.js에서는 Pages 폴더 아래 API 라는 폴더를 만들고 해당 폴더 안에 새로운 파일들을 배치시켜 주게 되면 그 파일들은 API Routes로서 웹페이지를 정의하는 파일이 아닌 API 응답을 정의하는 코드로서 설정이 된다~



현재시간을 반환하는 API를 만들어보자! 



time.ts



import { NextApiRequest, NextApiResponse } from "next";



export default function handler(

&nbsp;   req:NextApiRequest,

&nbsp;   res:NextApiResponse

){



}이러한 타입들은 Next.js에서 자체적으로 기본 제공하는 타입들임





import type { NextApiRequest, NextApiResponse } from "next";



export default function handler(req: NextApiRequest, res: NextApiResponse) {

&nbsp; const date = new Date();

&nbsp; res.json({ time: date.toLocaleString() });

}



이렇게 만들어주고 이렇게 되면 time이라는 api가 호출도ㅣ면 이 handler 함수가 실행됨

핸들러 함수에서는 새로운 date객체를 만들고 response 의 응답값으로 json객체를 응답하도록 설정되었음

http://localhost:3000/api/time

api의 time으로 접속 요청을 보내면

{"time":"2026. 2. 27. 오후 8:10:54"}

이런식으로 time이라는 프로퍼티안에 현재의 시간이 localsting으로 변환이 되어서 잘 들어가있는걸 확인할수있음



## **스타일링**

컴포넌트의 스타일링 리액트의 컴포넌트 스타일을 설정하는 과정과 동일하기 때문에

이전에 리액트에서 했던것과 거의 다 동일하게 진행을 해주면됨

/pages/index.tsx 의 홈 컴포넌트 스타일링을 해볼거임

export default function Home() {

&nbsp; return (

&nbsp;   <>

&nbsp;     <h1 style={{ color: "red" }}>인덱스ㅎㅎ</h1>

&nbsp;   </>

&nbsp; );

}

이런식으로 인라인 스타일링도 가능

보통 인라인 스타일 방식은 컴포넌트가 리턴해야하는 HTML요소가 많아지면 많아질수록 가독성을 해치기 때문에 보통은 CSS파일을 별도로 만들어서 분리해줌



index.tsx 파일을 위한 css파일을 만들어볼거임

보통은 동일한 위치에 동일한 이름으로 많이 만듦

_app.tsx 앱컴포넌트가 아닌 다른 index.tsx 같은 파일에서는 이렇게 임포트문을 통해서 css파일을 불러오는걸 제한함!!

_app.tsx 앱컴포넌트는 모든 페이지의 부모컴포넌트 역할을 하기 때문에 즉 바꿔말하면 모든 페이지에 적용되는 컴포넌트이기 때문에 글로벌 css역할을 할 파일을 위해서 app컴포넌트 에서만 예외적으로 import "@/styles/globals.css"를 불러오는걸 허용함
그래서 app 컴포넌트가 아니면 css파일을 그대로 불러오는건 불가능하다~

이때는 Next.js가 기본적으로 제공하는 CSS Module 라는 기능을 활용하면됨

기존의 CSS파일을 마치 모듈처럼 사용할 수 있도록 도와주는 기술!
클래스 네임들이 다른 CSS파일과 중복되지 않도록 클래스 네임들을 자동으로 유니크한 이름으로 파일마다 변환을 시켜주는 기능임

index.module.css
이렇게 쓰면됨 
index.module.css 파일 안에 들어있는 모든 클래스 네임들이 자동으로 유니크한 값으로 변환이 되어서 스타일이라는 객체 안에 저장됨

      <h1 className={style.h1}>인덱스ㅎㅎ</h1>
이렇게 사용하면 된다!

클래스 네임이 다른 파일과 겹치지 않게 유니크한 값으로 설정됨
개발자 모드에서 보면
<h1 class="index_h1__JHo3j">인덱스ㅎㅎ</h1>
이렇게 유니크한 이름들이 붙음
